from random import randint  # Импортируем модуль random для метода randint


# Класс Color
class Color:
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    DARKCYAN = '\033[36m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'

    def name_ver(self):
        print("\033[34m{}".format(self))

    name_ver("        Звездные войны ver.1.1\n"
             "...'Однажды в далекой-далекой галактике\n"
             "на бескрайних просторах Вселенной'...")


# Класс точка
class Dot:
    def __init__(self, x, y):  # Передаем через конструктор класса два параметра х, у (инициализируем экземпляры класса
        # после их создания через метод __init__())
        self.x = x  # Параметр класса
        self.y = y  # Параметр класса

    # Метод __eq__ отвечает за сравнение двух объектов (проверка на равенство)
    def __eq__(self, other):  # self - ссылка на экземпляр параметров класса
        # other - объект с которым следует произвести сравнение (справа от оператора сравнения).
        return self.x == other.x and self.y == other.y  # Возвращаем сравнение параметров класса

    # Метод __repr__ отвечает за вывод точек в консоль (выдает текстовое или строковое представление сущности или
    # объекта)
    def __repr__(self):
        return f"Dot({self.x}, {self.y})"  # Возвращаем вывод точек в консоль


# Общий класс исключений, который содержит остальные классы исключений
class BoardException(Exception):  # Через этот класс будем отлавливать исключения связанные с выполнением программы
    pass  # Оператор-заглушка


# Класс пользовательского исключения, когда пользователь пытается произвести ход вне придела доски
class BoardOutException(BoardException):
    def __str__(self):  # Метод __str__, который отображает пользователю информацию об объекте класса
        return Color.RED + "Ты стреляешь за пределы галактики, мой капитан!" + Color.END  # Возвращаем печать
        # сообщения в консоли


# Класс пользовательского исключения, когда пользователь пытается произвести ход, который уже совершал
class BoardUsedException(BoardException):
    def __str__(self):  # Метод __str__, который отображает пользователю информацию об объекте класса
        return Color.RED + "Капитан, мы уже делали это! У нас мало боеприпасов!" + Color.END  # Возвращаем печать
        # сообщения в консоли


# Общий класс исключений для размещения кораблей на игровом поле (этот класс никак не отображается для пользователя)
class BoardWrongShipException(BoardException):
    pass


# Класс корабля
class Ship:
    def __init__(self, bow, l, o):  # Передаем через конструктор класса параметры корабля
        self.bow = bow  # Нос корабля
        self.l = l  # Длина корабля
        self.o = o  # Точка размещения корабля
        self.lives = l  # Количество жизней корабля (сколько точек корабля еще не подбито)

    @property  # Определяем через декоратор @property, что метод dots вычисляет свойство корабля (точки расположения
    # и длину)
    # Метод dots. Создаем точки корабля (размеры или длину палуб)
    def dots(self):
        ship_dots = []  # В списке ship_dots будут находиться все точки корабля
        for i in range(self.l):  # Проходим по циклу в диапазоне: длина корабля -1
            cur_x = self.bow.x  # Создаем переменную по оси х с текущей точкой от носа корабля
            cur_y = self.bow.y  # Создаем переменную по оси у с текущей точкой от носа корабля

            if self.o == 0:  # Ориентация корабля по горизонту
                cur_x += i  #

            elif self.o == 1:  # Ориентация корабля по вертикали
                cur_y += i

            ship_dots.append(Dot(cur_x, cur_y))  # Добавляем через append список точек корабля на игровое поле

        return ship_dots  # Возвращаем список точек корабля на игровое поле

    # Метод shooting определяет попадание в корабль
    def shooting(self, shot):
        return shot in self.dots  # Возвращаем значение: было или нет попадание в точке по палубе корабля


# Класс игрового поля
class Board:
    def __init__(self, hid=False, size=6):  # Передаем через конструктор класса параметр игрового поля
        self.size = size  # Параметр размера поля
        self.hid = hid  # Параметр скрытия поля - информация о том, нужно ли скрывать корабли на доске (для вывода
        # доски противника), или нет (для своей доски).

        self.count = 0  # Переменная count - количество уничтоженных кораблей

        self.field = [[Color.BLUE + "O" + Color.END] * size for _ in range(size)]  # Атрибут field содержит размер
        # игрового поля с клетками, в которых будем храниться какое-то состояние поля, изначально будет храниться "O"
        # для обозначения клетки

        self.busy = []  # Атрибут busy, в которой будут храниться занятые точки (либо кораблями, которые будет
        # созданы; либо точки, в которые уже стреляли, после начала игры)
        self.ships = []  # В атрибуте ships будет храниться список кораблей на игровом поле

    # Метод add_ship лдя размещения корабля
    def add_ship(self, ship):

        for d in ship.dots:  # Для каждой точки корабля из списка проходим в цикле
            if self.out(d) or d in self.busy:  # Проверяем каждую точку корабля, чтобы та не выходила за границы
                # игрового поля или не была занята
                raise BoardWrongShipException()  # Если выходит, через инструкцию raise вызываем исключение
        for d in ship.dots:  # Для каждой точки корабля из списка проходим в цикле
            self.field[d.x][d.y] = Color.GREEN + "■" + Color.END  # В каждой из этих точек устанавливаем квадратик
            self.busy.append(d)  # Добавляем через append эти точки в список занятых

        self.ships.append(ship)  # Добавляем через append список кораблей на игровом поле
        self.contour(ship)  # Добавляем контур кораблей

    # Метод contour обозначает границы корабля
    def contour(self, ship, verb=False):
        near = [  # В переменной near находится список сдвигов точек по диагонали и по сторонам от начальной точки,
            # в которой мы находимся
            (-1, -1), (-1, 0), (-1, 1),
            (0, -1), (0, 0), (0, 1),
            (1, -1), (1, 0), (1, 1)
        ]
        for d in ship.dots:  # Для каждой точки корабля из списка проходим в цикле
            for dx, dy in near:  # Проходим в цикле для каждой точки корабля по списку near
                cur = Dot(d.x + dx, d.y + dy)  # Сдвигаем каждую точку из списка near по иси х и у
                if not (self.out(cur)) and cur not in self.busy:  # Если точка не выходит за границы игрового поля
                    # или не занята
                    if verb:  # Параметр verb отвечает за необходимость расстановки символа "." вокруг кораблей.
                        # До начала игры он заносит данный символ в список занятых, это не отображается на игровом поле
                        self.field[cur.x][cur.y] = Color.PURPLE + "." + Color.END  # Ставим на месте этой точки символ
                        # ".", для обозначения, что данный участок игрового поля занят
                    self.busy.append(cur)  # Добавляем через append эти точки в список занятых

    # Метод __str__ выводит корабли на доску
    def __str__(self):
        res = ""  # В переменной res будет записаны данные поля
        res += Color.BOLD + "  | 1 | 2 | 3 | 4 | 5 | 6 |" + Color.END  # Выводим нумерацию столбцов на игровом поле
        for i, row in enumerate(self.field):  # В цикле проходим по строкам доски. Через enumerate берем индекс строки i
            res += Color.BOLD + f"\n{i + 1} | " + Color.END + " | ".join(row) + " |"  # Через "{i + 1} | " выводим
            # нумерацию строк игрового поля, через " | ".join(row) выводим клетки строки, через \n повторяем цикл с
            # новой строки

        if self.hid:  # Через параметр hid будем определять сокрытие кораблей на игровом поле
            res = res.replace("■", Color.BLUE + "O" + Color.END)  # Метод replace заменяем символы корабля на копию
            # "0", если булевое значение истинно
        return res

    # Метод out определяет нахождение точки за пределами игрового поля
    def out(self, d):
        return not ((0 <= d.x < self.size) and (0 <= d.y < self.size))  # Параметр d (точка) должен быть больше/либо
        # равен нулю и меньше размера игрового поля по осям х и у

    # Метод shot производит выстрел
    def shot(self, d):
        if self.out(d):  # Если выстрел произведен за границы игрового поля
            raise BoardOutException()  # Если да, через инструкцию raise вызываем исключение

        if d in self.busy:  # Если выстрел произведен по занятой точке
            raise BoardUsedException()  # Если да, через инструкцию raise вызываем исключение

        self.busy.append(d)  # Добавляем через append точку, которая стала занята, если она не была занята до этого

        for ship in self.ships:  # Проходим в цикле по списку кораблей
            if d in ship.dots:  # Проверяем находится ли точка по который был произведен выстрел в списке кораблей
                ship.lives -= 1  # Уменьшаем количество жизней корабля, если корабль находится в точке выстрела
                self.field[d.x][d.y] = Color.RED + "X" + Color.END  # И ставим в эту точку обозначение, что корабль
                # был поражен
                if ship.lives == 0:  # Если у корабля кончились жизни (уничтожен)
                    self.count += 1  # Прибавляем к счетчику уничтоженных кораблей +1
                    self.contour(ship, verb=True)  # Обводим контур пораженного корабля уже с отображением контура на
                    # игровом поле
                    print(Color.RED + "Корабль уничтожен!" + Color.END)  # Выводим на печать сообщение об уничтожение
                    # корабля
                    return False  # Возвращаем True, чтобы игрок продолжил ход при уничтожении корабля противника или
                    # False, чтобы передать ход противнику
                else:  # Если корабль только ранен, а не уничтожен
                    print(Color.YELLOW + "Корабль ранен!" + Color.END)  # Выводим на печать сообщение, что корабль ранен
                    return True  # Возвращаем True, чтобы игрок продолжил ход или False, чтобы передать ход противнику

        self.field[d.x][d.y] = Color.YELLOW + "*" + Color.END  # Если выстрел произведен мимо, печатаем в этом месте
        # символ "T"
        print(Color.GREEN + "Мимо!" + Color.END)  # Выводим на печать сообщение, что игрок промахнулся
        return False  # Возвращаем False, чтобы передать ход противнику

    def begin(self):  # Обнуляем список busy, после начала игры, который использовался, до начала игры, для хранения
        # точек контуров кораблей
        self.busy = []  # После начала игры в этот список будут записываться точки, в которые стрелял игрок
        # Таким образом метод contour становиться универсальным


# Класс игрока
class Player:
    def __init__(self, board, enemy):  # Передаем через конструктор класса два параметра: игровые поля противников
        self.board = board
        self.enemy = enemy

    # Метод ask не определяем. Этот метод должен быть у потомков класса Player
    def ask(self):  # При попытке вызвать этот метод
        raise NotImplementedError()  # Через инструкцию raise вызываем исключение

    # Метод move. Попытка в бесконечном цикле произвести выстрел
    def move(self):
        while True:  # В бесконечном цикле производим выстрел на игровом поле
            try:
                target = self.ask()  # Запрашиваем у игрока ввод координат цели
                repeat = self.enemy.shot(target)  # Если заданные координаты попали в цель
                return repeat  # Повторяем запрос на ввод новых координат
            except BoardException as e:  # Если заданные координаты не попали по цели, вызываем исключение.
                # С помощью ключевого слова as записываем этот объект в переменную, чтобы обратиться к нему внутри
                # блока except
                print(e)  # Выводим информацию об ошибке


# Класс игрока ИИ
class AI(Player):
    def ask(self):  # Через метод ask запрашиваем координаты цели на игровом поле у игрока ИИ
        d = Dot(randint(0, 5), randint(0, 5))  # С помощью метода randint() генерируем координаты ввода на игровом
        # поле по оси х и у у игрока ИИ
        print(Color.BOLD + Color.CYAN + f"Ход Темной силы: {d.x + 1} {d.y + 1}" + Color.END)  # Выводим на печать
        # сгенерированный ход (добавляем +1 по осям, т.к. игровое поле начинается не с 0 при выводе в консоли)
        return d  # Возвращаем получившейся результат


# Класс игрока Пользователь
class User(Player):
    def ask(self):  # Через метод ask запрашиваем координаты цели на игровом поле у игрока Пользователь
        while True:  # В бесконечном цикле производим запрос на выстрел и проверку координат у игрока Пользователь
            cords = input(Color.BOLD + Color.DARKCYAN + "Ваш ход, капитан!\nВведите координаты:" + Color.END).split()
            # Выводим на печать просьбу ввести координаты выстрела на игровом поле. Метода split() возвращает введенные
            # данные как список

            if len(cords) != 2:  # Проверка ввода координат
                print(Color.YELLOW + "Уточните приказ!\nВведите 2 координаты! " + Color.END)  # Если координаты были
                # введены неверно, выводим на печать просьбу повторить попытку
                continue  # Через оператор continue повторяем цикл, пока не будут введены верные координаты

            x, y = cords

            if not (x.isdigit()) or not (y.isdigit()):  # С помощью метода isdigit() проверяем, чтобы введенные
                # координаты были числами
                print(Color.YELLOW + "Я не понимаю приказа!\nВведите два числа. " + Color.END)  # Если координаты
                # были введены неверно, выводим на печать просьбу повторить попытку
                continue  # Через оператор continue повторяем цикл, пока не будут введены верные координаты

            x, y = int(x), int(y)  # Преобразуем координаты х и у в целочисленный тип данных

            return Dot(x - 1, y - 1)  # Возвращаем получившейся результат (вычитываем -1 по осям, т.к игровое поле
            # начинается не с 0 при выводе в консоли)


# Функция greet приветствует Пользователя в игре и рассказывает о правилах
def greet():
    print(Color.GREEN + "-" * 20)
    print("  Приветствуем вас  ")
    print("      в игре       ")
    print("    морской бой    ")
    print(" по  мотивам фильма  ")
    print(Color.BOLD + "  'Звездные Войны'  " + Color.END)
    print(Color.GREEN + "-" * 20 + Color.END)
    print(Color.YELLOW + " формат ввода: x y ")
    print(" x - номер строки  ")
    print(" y - номер столбца " + Color.END)


# Класс игры
class Game:
    def __init__(self, size=6):  # Передаем через конструктор класса параметры и задаем размер игрового поля
        self.lens = [3, 2, 2, 1, 1, 1, 1]  # В переменной lens хранится список кораблей с их размерами
        self.size = size  # Размер игрового поля
        pl = self.random_board()  # Объявляем сгенерированное игровое поле для игрока Пользователь
        co = self.random_board()  # Объявляем сгенерированное игровое поле для игрока ИИ
        co.hid = False
        # Для игрока ИИ скрываем на игровом поле корабли

        self.ai = AI(co, pl)  # Объявляем игрока ИИ, передав доски из метода random_place
        self.us = User(pl, co)  # Объявляем игрока Пользователь, передав доски из метода random_place

    # Метод random_board генерирует случайное игровое поле
    def random_board(self):
        board = None  # Изначально игровое поле пустое
        while board is None:  # В бесконечном цикле пока игровое поле пустое
            board = self.random_place()  # с помощью метода randint() генерируем игровое поле
        return board  # Возвращаем сгенерированное игровое поле, после окончания цикла

    # Метод random_place для создания игрового поля и размещения кораблей на игровом поле
    def random_place(self):
        board = Board(size=self.size)  # В переменной board создаем игровое поле
        attempts = 0  # Переменная попыток установки кораблей
        for l in self.lens:  # Для каждой длинны корабля из переменной lens
            while True:  # в бесконечном цикле делаем попытку установки корабля
                attempts += 1  # После каждой итерации прибавляем +1 к переменной attempts
                if attempts > 2000:  # Если количество попыток установки кораблей больше 2000
                    return None  # Возвращаем None
                ship = Ship(Dot(randint(0, self.size), randint(0, self.size)), l, randint(0, 1))  # С помощью метода
                # randint() генерируем координаты по которым будет установлен корабль
                try:
                    board.add_ship(ship)  # Добавляем корабль на игровое поле, если сгенерированные координаты верны
                    break  # Прерываем цикл оператором break
                except BoardWrongShipException:  # Если выбрались все исключения, то начинаем итерацию заново
                    pass
        board.begin()  # Подготавливаем к игре игровое поле
        return board  # Возвращаем игровое поле

    # Метод print_board отображает игровое поле в консоли
    def print_board(self):
        print(Color.UNDERLINE + Color.DARKCYAN + "~" * 30 + Color.END)
        print(Color.BOLD + Color.DARKCYAN + "Игровое поле Светлой силы:" + Color.END)
        print(self.us.board)  # Выводим на печать в консоль игровое поле Пользователя
        print(Color.BOLD + Color.UNDERLINE + Color.CYAN + "~" * 30 + Color.END)
        print(Color.BOLD + Color.CYAN + "Игровое поле Темной силы:" + Color.END)
        print(self.ai.board)  # Выводим на печать в консоль игровое поле ИИ

    # Метод loop для создания игрового цикла
    def loop(self):
        num = 0  # Переменная num - номер хода
        while True:
            self.print_board()
            if num % 2 == 0:  # Если номер хода четный
                print(Color.UNDERLINE + Color.DARKCYAN + "~" * 30 + Color.END)
                print(Color.BOLD + Color.DARKCYAN + "Ходит Джедай!" + Color.END)
                repeat = self.us.move()  # то ходит Пользователь (вызываем метод move)
            else:
                print(Color.BOLD + Color.UNDERLINE + Color.CYAN + "~" * 30 + Color.END)
                print(Color.BOLD + Color.CYAN + "Ходит Ситх!" + Color.END)
                repeat = self.ai.move()  # иначе ходит ИИ (вызываем метод move)
            if repeat:  # Если заданные координаты введенные игроком попали в цель
                num -= 1  # данный игрок продолжает игру, номер хода уменьшается на -1, чтобы переменная num не
                # изменилась и номер хода остался у этого игрока

            if self.ai.board.count == 7:  # Проверяем количество пораженных кораблей. Если к этому моменту все корабли
                # были уничтожены Пользователем
                self.print_board()  # Отображаем финальное игровое поле, после победы Пользователем
                print(Color.UNDERLINE + Color.DARKCYAN + "~" * 30 + Color.END)
                print(Color.BOLD + Color.DARKCYAN + "Мой капитан, мы одержали победу!" + Color.END)  # Выводим на печать
                print(Color.RED + "░░░░░░░░░░░░░░▄▄▄▄▄░░░░░░░░░░░░░░\n"
                                  "░░░░░░░░░░▄██████████▄▄░░░░░░░░░░\n"
                                  "░░░░░░░░▄██████░█░██████▄░░░░░░░░\n"
                                  "░░░░░░▄████████░█░████████░░░░░░░\n"
                                  "░░░░░░█████████░█░█████████░░░░░░\n"
                                  "░░░░░▄█████████░█░█████████░░░░░░\n"
                                  "░░░░░██████████████████████░░░░░░\n"
                                  "░░░░░██████████████████████▄░░░░░\n"
                                  "░░░░▄████░░░░░▀█▄█▀░░░░░████░░░░░\n"
                                  "░░░▄█████░░░░░░█▄█░░░░░░█████░░░░\n"
                                  "░░▄████████▄▄▄█████▄▄▄████████░░░\n"
                                  "░▄████▀███████████████████▀████░░\n"
                                  "░████▀██████████░██████████▀████░\n"
                                  "████▀██████████░█░█▀████████▀████\n"
                                  "███▀▀░░░▀▀█▀█░█░█░█░█▀█▀▀░░░▀▀███\n"
                                  "░▀░░░░░░░░░░█░█░█░█░█░░░░░░░░░░▀░\n"
                                  "░░░░░░░░░░░░▀███████▀░░░░░░░░░░░░\n"
                                  "░░░░░░░░░░░░░░▀▀█▀▀░░░░░░░░░░░░░░" + Color.END)
                print(Color.BOLD + Color.CYAN + "Переходи на темную сторону Силы!" + Color.END)
                break

            if self.us.board.count == 7:  # Проверяем количество пораженных кораблей. Если к этому моменту все корабли
                # были уничтожены ИИ
                self.print_board()  # Отображаем финальное игровое поле, после победы ИИ
                print(Color.BOLD + Color.UNDERLINE + Color.CYAN + "~" * 30 + Color.END)
                print(Color.BOLD + Color.CYAN + "Ситхи одержали победу!" + Color.END)  # Выводим на печать
                print(Color.UNDERLINE + Color.DARKCYAN + "~" * 30 + Color.END)
                print(Color.BOLD + Color.DARKCYAN + "Капитан, нас разгромили!" + Color.END)
                print(Color.BOLD + Color.DARKCYAN + "░░░█▄░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▄██\n"
                                                    "░░░███▄▄░░░░░░░░░░▄▄▄▄▄▄░░░░░░░░░░▄▄███░\n"
                                                    "░░░███▀█▀█▄▄░░░▄█▀▀░░░░▀▀▄▄░░░▄▄█▀█▀▄█▀░\n"
                                                    "░░░░██▄░▀▄▄▀▀██▀░░░░░░░░░██▀█▀▀░▄█▀▄█▀░░\n"
                                                    "░░░░░██▄▄░▀▄█▀▀░░░░░░▄░░░░░▀█▄█▀░▄██▀░░░\n"
                                                    "░░░░░░▀█████▄▄░░░░░▀▄▀▄▀░░░░▄██▀██▀░░░░░\n"
                                                    "░░░░░░░░▄██▀▄███▄▄▄▄██▄▄▄▄███▄▀█▀█▄░░░░░\n"
                                                    "░░░░░░░█▀█░░▀██████▀▀▀▀████▀█▀░▀█▀█░░░░░\n"
                                                    "░░░░░░▀▀▀█░░░░▀▀▀█▀▀▀▀▀░█▀▀▀░░░█▀▀▀░░░░░\n"
                                                    "░░░░░░░░░▄█▄░░░░▄▀░░░░░▄▄█░░░▄██▄░░░░░░░\n"
                                                    "░░░░░░▄█▀░░▀█▄░░█░░▀▀▀▀░░█░▄█▀░░▀▀█▄░░░░\n"
                                                    "░░░▄█▀░░░░░░░░▀██▄░░░░░░▄▄█▀░░░░░░░░▀█▄░\n"
                                                    "░░░░███▄▄░░░░░░░░▀█▄█████▀░░░░░░░▄▄▄██▀░\n"
                                                    "░░▄█▀░░░░▀█▄▄░░░░░░▀█▀░▄▀░░░░▄▄▀▀░░░▀█▄░\n"
                                                    "▄█▀░░░░░░░░░▀▀█▄▄░░░▀▄▄▀░░▄▄▀█▄▄▄▄▄▄▄░██\n"
                                                    "▀░░░░░░░░░░░░░░░░▀▀▀░▀▀░░▀▀░░░░░░░░░░░▀▀" + Color.END)
                print(Color.BOLD + Color.DARKCYAN + "         В битве сомнений не должно быть.\n"
                                                    "         Должна быть только вера. \n"
                                                    "         Вера в Силу. Положись на нее.!" + Color.END)
                break
            num += 1

    # Метод launch для совместного запуска
    def launch(self):
        greet()
        self.loop()


g = Game()
g.launch()
